#include "osapi.h"
#include "../include/http_parse.h"

ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)
{
    // HTTP 0.9    请求行格式: [请求方法][空格..空格][URL](空格..空格)(回车符)[换行符]
    // HTTP >= 1.0 请求行格式: [请求方法][空格..空格][URL][空格..空格][协议版本][回车符][换行符]
    
    char  ch, *p,*m;
    
    enum {
        sw_start = 0,             // 初始状态
        sw_method,                // 解析请求方法
        sw_space_after_method,    // 解析请求方法后紧跟的一个空格
        sw_spaces_before_uri,     // 解析URL前可能存在的多余空格
        sw_schema,                // 解析schema(http/https)
        sw_schema_slash,          // 解析<schema>:后紧跟的一个/
        sw_schema_slash_slash,    // 解析<schema>:/后紧跟的一个/
        sw_host,                  // 解析<schema>://后紧跟的主机(域名/IP)
        sw_port,                  // 解析<schema>://<host>:后紧跟的端口
        sw_after_slash_in_uri,    // 解析URL路径中/后的内容
        sw_check_uri,             // ?
        sw_uri,                   // ?
        sw_http_09,               // 解析URL后紧跟空格后的内容
        sw_http_H,                // 解析协议版本的第二个字符T
        sw_http_HT,               // 解析协议版本的第三个字符T
        sw_http_HTT,              // 解析协议版本的第四个字符P
        sw_http_HTTP,             // 解析协议版本的第五个字符/
        sw_first_major_digit,     // 解析协议版本的主版本号的第一个数字
        sw_major_digit,           // 解析协议版本的主版本号第一个数字后的数字或者.
        sw_first_minor_digit,     // 解析协议版本的次版本号的第一个数字
        sw_minor_digit,           // 解析协议版本的次版本号第一个数字后的数字
        sw_almost_done,           // 解析结束的\n
        sw_done                   // 解析完成
    } state;                      // 枚举变量: HTTP请求行解析状态
 
    // 获取请求r的当前状态state
    state = r->state;
    // 获取缓冲区b的有效内容起始地址p
    p = b->pos;
 
    while (p < b->last && state < sw_done) {
        // p小于b->last时, 表明缓冲区内的有效内容不为空;
        // state小于sw_done, 表明未解析完成
        
        // ch指向缓冲区有效内容的第一个字符, p后移一位
        ch = *p++;
 
        switch (state) {
 
        /* HTTP methods: GET, HEAD, POST */
        case sw_start:
            // 当前状态为sw_start即起始状态
            
            // 置r->request_start为p-1, 也就是当前字符的位置
            r->request_start = p - 1;
 
            if (ch == CR || ch == LF) {
                // 如果当前字符为\r或者\n
                
                // 跳过
                break;
            }
 
            if (ch < 'A' || ch > 'Z') {
                // 如果当前字符不是大写字母
                
                // 请求方法必须是由大写字母组成的, 所以返回NGX_HTTP_PARSE_INVALID_METHOD,
                // 从字面上可以看出, 这个返回值表示无效的请求方法
                return NGX_HTTP_PARSE_INVALID_METHOD;
            }
 
            // 置state为sw_method, 表示解析请求方法
            state = sw_method;
            break;
 
        case sw_method:
            // 当前状态为解析请求方法
            
            if (ch == ' ') {
                // 如果当前字符为空格
                
                // 说明遇到了请求方法后面的空格了, p-2即为请求方法的最后一个字符
                // 置r->method_end为p-1, 记录请求方法的结束位置
                r->method_end = p - 1;
                // r->request_start此时指向的是请求方法的第一个字符
                m = r->request_start;
 
                if (r->method_end - (uint16)m == 3) {
                    // 如果请求方法子字符串的长度为3
 
                    if (m[0] == 'G' && m[1] == 'E' && m[2] == 'T') {
                        // 如果请求方法子字符串为GET
                        
                        // 置r->method为NGX_HTTP_GET
                        r->method = NGX_HTTP_GET;
                    }
 
                } else if (r->method_end - (uint16)m == 4) {
                    // 如果请求方法子字符串的长度为4
 
                    if (m[0] == 'P' && m[1] == 'O'
                        && m[2] == 'T' && m[3] == 'T')
                    {
                        // 如果请求方法子字符串为POST
                        
                        // 置r->method为NGX_HTTP_POST
                        r->method = NGX_HTTP_POST;
 
                    } else if (m[0] == 'H' && m[1] == 'E'
                               && m[2] == 'A' && m[3] == 'D')
                    {
                        // 如果请求方法子字符串为HEAD
                        
                        // 置r->method为NGX_HTTP_HEAD
                        r->method = NGX_HTTP_HEAD;
                    }
                }
 
                // 解析完请求方法, 置state为sw_spaces_before_uri, 表示解析URL前面的空格
                // 因为此处已经解析到一个请求方法后的空格, 所以跳过状态sw_space_after_method,
                state = sw_spaces_before_uri;
                break;
            }
 
            if (ch < 'A' || ch > 'Z') {
                // 如果当前字符不是大写字母
                
                // 返回NGX_HTTP_PARSE_INVALID_METHOD
                return NGX_HTTP_PARSE_INVALID_METHOD;
            }
 
            break;
 
        case sw_space_after_method:
            // 当前状态为解析请求方法后紧跟的一个空格
            
            switch (ch) {
            case ' ':
                // 如果当前字符为空格
                
                // 置state为sw_spaces_before_uri, URL前面可能还有空格
                state = sw_spaces_before_uri;
                break;
            default:
                // 如果当前字符为非空格的字符
                
                // 请求方法和URL之间至少需要一个空格,
                // 返回NGX_HTTP_PARSE_INVALID_METHOD
                return NGX_HTTP_PARSE_INVALID_METHOD;
            }
            break;
 
        case sw_spaces_before_uri:
            // 当前状态为解析URL前可能存在的多余空格
            
            switch (ch) {
            case '/':
                // 如果当前字符为/, 说明遇到URL的第一个字符
                
                // 置r->uri_start为p-1, 记录URL的起始位置
                r->uri_start = p - 1;
                // 置state为sw_after_slash_in_uri, 表示解析URL路径中/后的内容
                state = sw_after_slash_in_uri;
                break;
            case ' ':
                // 如果当前字符为空格
                
                // 直接跳过
                break;
            default:
                if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {
                    // 如果当前字符为大小写字母, 说明遇到schema(http/https)的第一个字符了
                    
                    // 置r->schema_start为p-1, 记录schema的起始位置
                    r->schema_start = p - 1;
                    // 置state为sw_schema, 表示解析schema
                    state = sw_schema;
                    break;
                }
                // 当前字符为其他字符, 表示请求有误, 返回NGX_HTTP_PARSE_INVALID_REQUEST,
                // 即无效请求
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_schema:
            // 当前状态为解析schema
            
            switch (ch) {
            case ':':
                // 如果当前字符为：, 说明遇到schema的后一个字符了
                
                // 置r->schema_end为p-1, 记录schema的结束位置
                r->schema_end = p - 1;
                // 置state为sw_schema_slash, 表示解析<schema>:后紧跟的一个/
                state = sw_schema_slash;
                break;
            default:
                if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {
                    // 如果当前字符是大小写字符, 说明是我们想要的
                    
                    // 直接跳过
                    break;
                }
                // 当前字符为其他字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_schema_slash:
            // 当前状态为解析<schema>:后紧跟的一个/
            switch (ch) {
            case '/':
                // 如果当前字符正是/
                
                // 置state为sw_schema_slash_slash, 解析紧跟的一个/
                state = sw_schema_slash_slash;
                break;
            default:
                // 当前字符不为/, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_schema_slash_slash:
            // 当前状态为解析<schema>:/后紧跟的一个/
            
            switch (ch) {
            case '/':
                // 如果当前字符正是/
                
                // 置r->host_start为p-1, 记录URL中主机的起始位置
                r->host_start = p - 1;
                // 置state为sw_host, 表示解析<schema>://后紧跟的主机
                state = sw_host;
                break;
            default:
                // 当前字符不为/, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_host:
            // 当前状态为解析<schema>://后紧跟的主机
            
            switch (ch) {
            case ':':
                // 如果当前字符为:, 说明遇到主机后紧跟的一个:了
                
                // 置r->host_end为p-1, 记录主机的结束位置
                r->host_end = p - 1;
                // 置state为sw_port, 因为遇到主机后紧跟的:了, 那么此:后需要跟着端口号
                state = sw_port;
                break;
            case '/':
                // 如果当前字符是/, 因为主机后的:<port>不是必须的,
                // 说明遇到主机后紧跟的一个/了
                
                // 置r->host_end为p-1, 记录主机的结束位置
                r->host_end = p - 1;
                // 置r->uri_start为p-1, 记录URL中路径的起始地址
                r->uri_start = p - 1;
                // 置state为sw_after_slash_in_uri, 表示解析URL路径中/后的内容
                state = sw_after_slash_in_uri;
                break;
            default:
                if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')
                    || (ch >= '0' && ch <= '9') || ch == '.' || ch == '-')
                {
                    // 如果当前字符为大小写字母、数字、.、-, 说明是主机(域名/IP)的有效字符
                    
                    // 直接跳过
                    break;
                }
                // 当前字符为其他字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_port:
            // 当前状态为解析<schema>://<host>:后紧跟的端口
            switch (ch) {
            case '/':
                // 如果当前字符为/, 说明遇到端口后紧跟的一个/了
                
                // 置r->port_end为p-1, 记录端口的结束位置
                r->port_end = p - 1;
                // 置r->uri_start为p-1, 记录URL中路径的起始位置
                r->uri_start = p - 1;
                // 置state为sw_after_slash_in_uri, 表示解析URL路径中/后的内容
                state = sw_after_slash_in_uri;
                break;
            default:
                if (ch < '0' && ch > '9') {
                    // 如果当前字符不为数字, 端口必须由数字组成, 说明是非法字符
                    // 返回NGX_HTTP_PARSE_INVALID_REQUEST
                    return NGX_HTTP_PARSE_INVALID_REQUEST;
                }
                break;
            }
            break;
 
        case sw_after_slash_in_uri:
            // 当前状态为解析URL路径中/后的内容
            switch (ch) {
            case CR:
                // 如果当前字符为\r, 说明可能是HTTP 0.9
                
                // 置r->uri_end为p-1, 记录URL中路径的结束位置
                r->uri_end = p - 1;
                // 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_almost_done, 表示解析结束的\n
                state = sw_almost_done;
                break;
            case LF:
                // 如果当前字符为\n, 说明可能是HTTP 0.9
                
                // 置r->uri_end为p-1, 记录URL中路径的结束位置
                r->uri_end = p - 1;
                // 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            case ' ':
                // 如果当前字符为空格, 表示遇到URL(或者路径)后紧跟的一个空格
                
                // 置r->uri_end为p-1, 记录URL中路径的结束位置
                r->uri_end = p - 1;
                // 置state为sw_http_09, 表示解析URL后紧跟空格后的内容
                state = sw_http_09;
                break;
            case '.':
            case '%':
                // 如果当前字符为.或者%, 说明是复杂的URL
                
                // 置r->complex_uri为1
                r->complex_uri = 1;
                // 置state为sw_uri
                state = sw_uri;
                break;
            case '/':
                // 如果当前字符为/
                
                // 置r->complex_uri为1
                // 因为仍要解析/后的内容, 因此state不变
                r->complex_uri = 1;
                break;
            case '?':
                // 如果当前字符为?, 说明遇到了URL中的参数
                
                // 置r->args_start为p, 记录参数的起始位置
                r->args_start = p;
                // 置state为sw_uri
                state = sw_uri;
                break;
            default:
                // 如果当前字符为其他字符
                // 置state为sw_check_uri
                state = sw_check_uri;
                break;
            }
            break;
 
        case sw_check_uri:
            // 当前状态为sw_check_uri
            
            switch (ch) {
            case CR:
                // 如果当前字符为\r, 说明遇到了URL后紧跟的\r
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 显然是HTTP 0.9, 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_almost_done, 表示解析结束的\n
                state = sw_almost_done;
                break;
            case LF:
                // 如果当前字符为\n, 说明遇到了URL后紧跟的\n
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 显然是HTTP 0.9, 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            case ' ':
                // 如果当前字符为空格, 表明遇到URL后紧跟的一个空格
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 置state为sw_http_09, 表示解析URL后紧跟空格后的内容
                state = sw_http_09;
                break;
            case '.':
                // 如果当前字符为., 表明遇到扩展名
                
                // 置r->uri_ext为p, 记录扩展名的起始位置
                r->uri_ext = p;
                break;
            case '/':
                // 如果当前字符为/ 
                
                // 那么之前记录的"扩展名"其实不是真的扩展名, 置r->uri_ext为空
                r->uri_ext = NULL;
                // 置state为sw_after_slash_in_uri, 因为仍在解析URL且遇到了/
                state = sw_after_slash_in_uri;
                break;
            case '%':
                // 如果当前字符为%, 表明是复杂的URL
                
                // 置r->complex_uri为1
                r->complex_uri = 1;
                // 置state为sw_uri
                state = sw_uri;
                break;
            case '?':
                // 如果当前字符为?, 表明遇到了参数
                
                // 置r->args_start为p, 记录参数的起始位置
                r->args_start = p;
                // 置state为sw_uri
                state = sw_uri;
                break;
            }
            break;
 
        case sw_uri:
            // 当前状态为sw_uri
            
            switch (ch) {
            case CR:
                // 如果当前字符为\r, 说明遇到了URL后紧跟的\r
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 显然是HTTP 0.9, 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_almost_done, 表示解析结束的\n
                state = sw_almost_done;
                break;
            case LF:
                // 如果当前字符为\n, 说明遇到了URL后紧跟的\n
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 显然是HTTP 0.9, 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            case ' ':
                // 如果当前字符为空格, 表明遇到URL后紧跟的一个空格
                
                // 置r->uri_end为p-1, 记录URL的结束位置
                r->uri_end = p - 1;
                // 置state为sw_http_09, 表示解析URL后紧跟空格后的内容
                state = sw_http_09;
                break;
            }
            break;
 
        case sw_http_09:
            // 当前状态为解析URL后紧跟空格后的内容
            
            switch (ch) {
            case ' ':
                // 如果当前字符为空格, 直接跳过
                break;
            case CR:
                // 如果当前字符为\r, 说明是HTTP 0.9
                
                // 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_almost_done, 表示解析结束的\n
                state = sw_almost_done;
                break;
            case LF:
                // 如果当前字符为\n, 说明是HTTP 0.9
                
                // 置r->http_minor为9
                r->http_minor = 9;
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            case 'H':
                // 如果当前字符是H, 说明是HTTP >= 1.0
                
                // 置state为sw_http_H, 表示解析协议版本的第二个字符T
                state = sw_http_H;
                break;
            default:
                // 当前字符为其他字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_http_H:
            // 当前状态为解析协议版本的第二个字符T
            switch (ch) {
            case 'T':
                // 如果当前字符正是T
                
                // 置state为sw_http_HT
                state = sw_http_HT;
                break;
            default:
                // 当前字符不为T, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_http_HT:
            // 当前状态为解析协议版本的第三个字符T
            
            switch (ch) {
            case 'T':
                // 如果当前字符正是T
                
                // 置state为sw_http_HTT
                state = sw_http_HTT;
                break;
            default:
                // 当前字符不为T, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_http_HTT:
            // 当前状态为解析协议版本的第四个字符P
            
            switch (ch) {
            case 'P':
                // 如果当前字符正是P
                
                // 置state为sw_http_HTTP
                state = sw_http_HTTP;
                break;
            default:
                // 当前字符不为P, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_http_HTTP:
            // 当前状态为解析协议版本的第五个字符/
            
            switch (ch) {
            case '/':
                // 如果当前字符正是/
                
                // 置state为sw_first_major_digit
                state = sw_first_major_digit;
                break;
            default:
                // 当前字符不为/, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_first_major_digit:
            // 当前状态为解析协议版本的主版本号的第一个数字
            if (ch < '1' || ch > '9') {
                // 如果当前字符不为数字1-9, 说明是无效字符;
                // 协议版本应该是在HTTP 1.0后才有的, 因此主版本号应该不小于1;
                // 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            // 置r->http_major为ch-'0', 记录主版本号
            r->http_major = ch - '0';
            // 置state为sw_major_digit, 表示解析协议版本的主版本号第一个数字后的数字或者.
            state = sw_major_digit;
            break;
 
        case sw_major_digit:
            // 当前状态为解析协议版本的主版本号第一个数字后的数字或者.
            
            if (ch == '.') {
                // 如果当前字符为., 说明遇到主版本号后紧跟的.了
                // 置state为sw_first_minor_digit, 表示解析次版本号的第一个数字
                state = sw_first_minor_digit;
                break;
            }
 
            if (ch < '0' || ch > '9') {
                // 如果当前字符不为数字, 说明是非法字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            // 更新主版本号r->http_major
            r->http_major = r->http_major * 10 + ch - '0';
            break;
 
        case sw_first_minor_digit:
            // 当前状态为解析协议版本的次版本号的第一个数字
            
            if (ch < '0' || ch > '9') {
                // 如果当前字符不为数字, 说明是非法字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            // 置r->http_minor为ch-'0', 记录次版本号
            r->http_minor = ch - '0';
            // 置state为sw_minor_digit, 表示解析协议版本的次版本号第一个数字后的数字
            state = sw_minor_digit;
            break;
 
        case sw_minor_digit:
            // 当前状态为解析协议版本的次版本号第一个数字后的数字
            
            if (ch == CR) {
                // 如果当前字符为\r, 说明遇到次版本号后紧跟的\r
                // 置state为sw_almost_done, 表示解析结束的\n
                state = sw_almost_done;
                break;
            }
 
            if (ch == LF) {
                // 如果当前字符为\n, 说明遇到次版本号后的\n
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            }
 
            if (ch < '0' || ch > '9') {
                // 如果当前字符不为数字, 说明是非法字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            // 更新次版本号r->http_minor
            r->http_minor = r->http_minor * 10 + ch - '0';
            break;
 
        case sw_almost_done:
            // 当前状态为解析结束的\n
            
            // 置r->request_end为p-2, 记录请求行有效内容的结束位置
            r->request_end = p - 2;
            switch (ch) {
            case LF:
                // 如果当前字符正是\n
                
                // 置state为sw_done, 表示解析完成
                state = sw_done;
                break;
            default:
                // 如果当前字符不是\n, 那么就是非法字符, 返回NGX_HTTP_PARSE_INVALID_REQUEST
                return NGX_HTTP_PARSE_INVALID_REQUEST;
            }
            break;
 
        case sw_done:
            // 当前状态为解析完成, 直接退出循环
            break;
        }
    }
 
    // 置缓冲区的pos为p
    b->pos = p;
 
    if (state == sw_done) {
        // 如果state为sw_done, 表明解析完成
        
        if (r->request_end == NULL) {
            // 如果r->request_end为空
            
            // 置r->request_end为p-1, p-1即为请求行的结束位置
            r->request_end = p - 1;
        }
 
        // 求取HTTP版本, 规则为: 主版本号*1000+次版本号
        // 所以,0.9->9, 1.0->1000, 1.1->1001
        r->http_version = r->http_major * 1000 + r->http_minor;
        // 重置请求r的state为sw_start
        r->state = sw_start;
 
        if (r->http_version == 9 && r->method != NGX_HTTP_GET) {
            // 如果为HTTP 0.9且请求方法不为GET
            
            // 返回NGX_HTTP_PARSE_INVALID_09_METHOD, 说明HTTP 0.9只支持GET方法
            return NGX_HTTP_PARSE_INVALID_09_METHOD;
        }
 
        return NGX_OK;
 
    } else {
        // 没有解析完
        
        // 记录当前解析状态
        r->state = state;
        // 返回NGX_AGAIN
        return NGX_AGAIN;
    }
}
